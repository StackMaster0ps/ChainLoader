{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\froman\fcharset0 Times-Italic;\f2\froman\fcharset0 Times-Bold;
\f3\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red109\green109\blue109;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c50196\c50196\c50196;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid101\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid401\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid501\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid502\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid601\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid7}
{\list\listtemplateid8\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid701\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid8}
{\list\listtemplateid9\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid801\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid9}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}{\listoverride\listid9\listoverridecount0\ls9}}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Below is a conceptual explanation of why simply writing to \'93vacant bit-addressable memory channels or address spaces\'94\'97in other words, 
\f1\i unused
\f0\i0  areas of RAM\'97typically 
\f2\b won\'92t work
\f0\b0  for persisting code or data beyond the early boot stage in a reliable way. While there have been historical or specialized hacks that stash code in certain memory regions, modern Windows systems (and modern hardware in general) make this approach 
\f1\i highly unreliable
\f0\i0  and often 
\f2\b not feasible
\f0\b0  as a stable method of injection. Let\'92s break down why.\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 \
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 \strokec2 1. How the BIOS Boot Process Initializes Memory\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Legacy BIOS
\f0\b0  loads the Master Boot Record (MBR) into low memory at 
\f3\fs26 0x0000:0x7C00
\f0\fs24 .\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The system remains in 
\f2\b real mode
\f0\b0 , with a 1 MB addressable range (actually up to 0xFFFFF, plus some overlap).\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Once you chain-load Windows or another modern OS, the OS typically 
\f2\b re-initializes the memory controller
\f0\b0 , sets up protected mode (or long mode, 64-bit), and redefines how physical memory is mapped to virtual addresses.\
\pard\pardeftab720\sa240\partightenfactor0

\f2\b \cf0 \strokec2 Key Point
\f0\b0 : Any data you place in some \'93vacant\'94 memory region at real-mode boot time is 
\f2\b not guaranteed
\f0\b0  to remain intact once the OS sets up new memory tables and begins normal operation.\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 \
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 \strokec2 2. Operating System Memory Management\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b0\fs24 \cf0 Modern operating systems\'97especially Windows\'97do the following during startup:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Memory Detection
\f0\b0 : They query or read from ACPI tables, memory maps, or UEFI services to determine which physical addresses are usable (i.e., \'93free memory\'94) vs. reserved for hardware.\
\ls2\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Initialize Paging
\f0\b0 : In 64-bit Windows, the kernel sets up 
\f1\i virtual memory paging
\f0\i0  and typically 
\f2\b zeroes out
\f0\b0  or reclaims large sections of RAM for security reasons.\
\ls2\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Security Measures
\f0\b0 : Windows attempts to ensure no leftover data from pre-boot stages remains in allocated user-space or kernel-space memory. This prevents security issues like reading stale data.\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \strokec2 Thus, a random chunk of memory you used in real mode is either:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls3\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Overwritten
\f0\b0  by the OS memory initialization process.\
\ls3\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Marked
\f0\b0  as free and later allocated to random processes, which can either overwrite or read it.\
\ls3\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Never actually mapped
\f0\b0  to any useful location in virtual address space.\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 \
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 \strokec2 3. Historical Tricks vs. Modern Realities\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b0\fs24 \cf0 In older DOS-era or early Windows (9x) systems, a few \'93tricks\'94 existed:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls4\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Hiding data in the HMA
\f0\b0  (High Memory Area) or UMB (Upper Memory Blocks).\
\ls4\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Stashing code in video memory
\f0\b0  if you were certain the OS or drivers wouldn\'92t overwrite it.\
\ls4\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Using shadow RAM
\f0\b0  in certain chipset or BIOS areas.\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \strokec2 However, in modern Windows NT-based systems (especially x64):\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls5\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Protected Mode / Long Mode
\f0\b0 : The OS reconfigures the CPU to use full paging. Physical addresses are not the same as virtual addresses.\
\ls5\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Drivers
\f0\b0 : Windows loads storage, display, and other drivers that can reinitialize hardware, clearing or overwriting previously used buffers.\
\ls5\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Memory Scrubbing
\f0\b0 : Windows tries to ensure that no leftover secrets or code remain from uninitialized areas for security reasons.\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \strokec2 Therefore, those old memory-hiding methods 
\f1\i rarely survive
\f0\i0  the transition to modern Windows boot.\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 \
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 \strokec2 4. Specialized Exceptions\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls6\ilvl0
\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 ACPI S3 (Suspend to RAM)
\f0\b0  or 
\f2\b S4 (Hibernate)
\f0\b0 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls6\ilvl1\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In some cases, code placed in certain physical memory ranges could survive a sleep or hibernate cycle if the hardware doesn\'92t fully clear RAM. But this requires very specific conditions and does not necessarily run the code unless you also hook the resume process.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls6\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 SMRAM
\f0\b0  (System Management RAM) or 
\f2\b Intel ME
\f0\b0 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls6\ilvl1\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Very specialized firmware-level or chipset-level hacking. Not trivial; typically highly protected.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls6\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 PCI Expansion ROM
\f0\b0 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\partightenfactor0
\ls6\ilvl1\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Some malicious techniques involve writing code to a PCI device\'92s expansion ROM or configuring it to load code. 
\f1\i Again, advanced and not guaranteed.
\f0\i0 \
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \strokec2 These are advanced hardware-level attacks, far outside the realm of a straightforward \'93place code in vacant memory\'94 at normal boot.\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 \
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 \strokec2 5. Why It Usually Doesn\'92t \'93Carry Past the .exe Files\'94\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b0\fs24 \cf0 Once Windows starts booting:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls7\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 bootmgr
\f0\b0  or 
\f2\b winload.exe
\f0\b0  runs in a protected environment.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls7\ilvl0\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 They do not simply read random physical addresses hoping to find instructions. Instead, they load files from disk (e.g., drivers, kernel), and map them into memory with specific addresses.\
\ls7\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Any memory region that was used by the BIOS or MBR is either overwritten or repurposed, often zeroed.\
\pard\pardeftab720\sa240\partightenfactor0

\f2\b \cf0 \strokec2 In short
\f0\b0 : Even if you do manage to stash code in a \'93free\'94 area of RAM at real-mode boot, there is no built-in mechanism for Windows to later discover or execute it.\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 \
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 \strokec2 6. Alternative Approaches\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b0\fs24 \cf0 If your goal is to run code 
\f1\i beyond
\f0\i0  the MBR stage\'97e.g., after Windows is up\'97you typically:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls8\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Multi-Stage Bootloader
\f0\b0 : As we\'92ve discussed, the MBR (Stage 1) can load a more complex Stage 2 from disk, which can patch or inject code where you want.\
\ls8\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Patching Boot Files
\f0\b0 : Instead of ephemeral memory stashing, you patch disk files like 
\f3\fs26 bootmgr
\f0\fs24 , 
\f3\fs26 winload.exe
\f0\fs24 , or a kernel driver\'97assuming you can handle signatures, Secure Boot, etc.\
\ls8\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Driver Injection
\f0\b0 : Place a driver in 
\f3\fs26 \\Windows\\System32\\drivers\\
\f0\fs24  + registry modifications so Windows loads it at startup.\
\ls8\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	4	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 UEFI Drivers
\f0\b0  (If using UEFI boot): You could place your own 
\f3\fs26 .efi
\f0\fs24  driver in the EFI System Partition to be loaded by the firmware or chain-loaded at some point.\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \strokec2 All these are more reliable, as they don\'92t rely on the OS not overwriting memory that you arbitrarily chose.\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 \
\pard\pardeftab720\sa298\partightenfactor0

\f2\b\fs36 \cf0 \strokec2 7. Conclusion\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls9\ilvl0
\f0\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Simply writing code or data to \'93vacant memory addresses\'94 at early boot is 
\f2\b not
\f0\b0  a robust way to carry code past 
\f3\fs26 bootmgr
\f0\fs24  or 
\f3\fs26 .exe
\f0\fs24  loading on a modern Windows system.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls9\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Reason
\f0\b0 : Once Windows initializes, it remaps or re-initializes memory and loads actual drivers and kernel code, effectively ignoring or wiping anything left in arbitrary low memory.\
\ls9\ilvl0
\f2\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Realistic Approach
\f0\b0 : Use multi-stage loaders, patch actual disk files, or inject a driver that Windows will load in a documented or systematic way.\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \strokec2 Ultimately, while it might be 
\f1\i theoretically possible
\f0\i0  to find a weird corner of memory that remains untouched (especially on older hardware/OS), it is 
\f2\b unreliable
\f0\b0  and 
\f1\i not standard or straightforward
\f0\i0 \'97particularly in Windows 10/11 with modern security practices.\
}